// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v3.21.12
// source: TTSTypes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "aristech.tts";

/** Further options for a `SpeechRequest`. */
export interface SpeechRequestOption {
  /**
   * The `voiceId` from `Voice` to use as wrapping voice to synthesize text.
   * Note: The `voiceId` can also be swapped within the text by using ssml's
   * `<voice/>` tag with another `voiceId`.
   */
  voiceId: string;
  /** Further options that specify the generated audio. */
  audio:
    | SpeechAudioFormat
    | undefined;
  /**
   * If the text should be normalized before being transformed into audio or
   * not.
   */
  normalize: boolean;
  /**
   * If the server should fetch audio from cache or save the audio to cache if
   * enabled.
   */
  cache: boolean;
}

/**
 * `SpeechRequestOptionAudioFormat` specifies the retured audio format for a
 * `getSpeech` request.
 */
export interface SpeechAudioFormat {
  /** The container to use. */
  container: SpeechAudioFormat_Container;
  /** The encoding of the audio. */
  codec: SpeechAudioFormat_Codec;
  /** The samplerate of the audio. */
  samplerate: number;
  /** The bitrate of the audio. */
  bitrate: number;
  /** The channels count of the audio. */
  channels: number;
}

/** Indicates the container of the audio. */
export enum SpeechAudioFormat_Container {
  /** WAV - wav */
  WAV = 0,
  /** RAW - raw */
  RAW = 1,
  /** FLAC - flac */
  FLAC = 2,
  /** OGG - ogg */
  OGG = 3,
  /** MP3 - mp3 */
  MP3 = 4,
  /** SPEEX - speex */
  SPEEX = 5,
  UNRECOGNIZED = -1,
}

export function speechAudioFormat_ContainerFromJSON(object: any): SpeechAudioFormat_Container {
  switch (object) {
    case 0:
    case "WAV":
      return SpeechAudioFormat_Container.WAV;
    case 1:
    case "RAW":
      return SpeechAudioFormat_Container.RAW;
    case 2:
    case "FLAC":
      return SpeechAudioFormat_Container.FLAC;
    case 3:
    case "OGG":
      return SpeechAudioFormat_Container.OGG;
    case 4:
    case "MP3":
      return SpeechAudioFormat_Container.MP3;
    case 5:
    case "SPEEX":
      return SpeechAudioFormat_Container.SPEEX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SpeechAudioFormat_Container.UNRECOGNIZED;
  }
}

export function speechAudioFormat_ContainerToJSON(object: SpeechAudioFormat_Container): string {
  switch (object) {
    case SpeechAudioFormat_Container.WAV:
      return "WAV";
    case SpeechAudioFormat_Container.RAW:
      return "RAW";
    case SpeechAudioFormat_Container.FLAC:
      return "FLAC";
    case SpeechAudioFormat_Container.OGG:
      return "OGG";
    case SpeechAudioFormat_Container.MP3:
      return "MP3";
    case SpeechAudioFormat_Container.SPEEX:
      return "SPEEX";
    case SpeechAudioFormat_Container.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates the codec of the audio. */
export enum SpeechAudioFormat_Codec {
  /** PCM - pcm a.k.a. signed-integer */
  PCM = 0,
  /** MU_LAW - mu-law */
  MU_LAW = 1,
  /** A_LAW - a-law */
  A_LAW = 2,
  UNRECOGNIZED = -1,
}

export function speechAudioFormat_CodecFromJSON(object: any): SpeechAudioFormat_Codec {
  switch (object) {
    case 0:
    case "PCM":
      return SpeechAudioFormat_Codec.PCM;
    case 1:
    case "MU_LAW":
      return SpeechAudioFormat_Codec.MU_LAW;
    case 2:
    case "A_LAW":
      return SpeechAudioFormat_Codec.A_LAW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SpeechAudioFormat_Codec.UNRECOGNIZED;
  }
}

export function speechAudioFormat_CodecToJSON(object: SpeechAudioFormat_Codec): string {
  switch (object) {
    case SpeechAudioFormat_Codec.PCM:
      return "PCM";
    case SpeechAudioFormat_Codec.MU_LAW:
      return "MU_LAW";
    case SpeechAudioFormat_Codec.A_LAW:
      return "A_LAW";
    case SpeechAudioFormat_Codec.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a languages locale. */
export interface SpeechLocale {
  /** Example locale: de_DE */
  language: string;
  /** ex.: DE */
  accent: string;
  /** ex.: Deutsch */
  languageName: string;
  /** ex.: Deutschland */
  accentName: string;
}

/** holds some default config values of a voice */
export interface VoiceDefaults {
  rate: string;
  pitch: string;
}

/** Contains several infos about a voice */
export interface Voice {
  /** [Output-only] The voice name. */
  name: string;
  /** [Output-only] The audio type of the voice. */
  audio:
    | SpeechAudioFormat
    | undefined;
  /** [Output-only] The locale of the voice. */
  locale:
    | SpeechLocale
    | undefined;
  /** [Output-only] The gender of the voice. */
  gender: Voice_Gender;
  /**
   * [Output-only] The voice id.
   * This is the value to use as `SpeechRequestOption.voice_id`
   */
  voiceId: string;
  /** [Output-only] The uuid of the voice. */
  uuid: string;
  /** The version number of the voice */
  version: string;
  /** available ports for the voice as configured in the license; */
  portsAvailable: number;
  /** whether debug is available for the voice (only with developer license) */
  debugAvailable: boolean;
  /** default config values */
  defaults: VoiceDefaults | undefined;
}

export enum Voice_Gender {
  FEMALE = 0,
  MALE = 1,
  OTHER = 2,
  UNRECOGNIZED = -1,
}

export function voice_GenderFromJSON(object: any): Voice_Gender {
  switch (object) {
    case 0:
    case "FEMALE":
      return Voice_Gender.FEMALE;
    case 1:
    case "MALE":
      return Voice_Gender.MALE;
    case 2:
    case "OTHER":
      return Voice_Gender.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Voice_Gender.UNRECOGNIZED;
  }
}

export function voice_GenderToJSON(object: Voice_Gender): string {
  switch (object) {
    case Voice_Gender.FEMALE:
      return "FEMALE";
    case Voice_Gender.MALE:
      return "MALE";
    case Voice_Gender.OTHER:
      return "OTHER";
    case Voice_Gender.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseSpeechRequestOption(): SpeechRequestOption {
  return { voiceId: "", audio: undefined, normalize: false, cache: false };
}

export const SpeechRequestOption: MessageFns<SpeechRequestOption> = {
  encode(message: SpeechRequestOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.voiceId !== "") {
      writer.uint32(10).string(message.voiceId);
    }
    if (message.audio !== undefined) {
      SpeechAudioFormat.encode(message.audio, writer.uint32(18).fork()).join();
    }
    if (message.normalize !== false) {
      writer.uint32(24).bool(message.normalize);
    }
    if (message.cache !== false) {
      writer.uint32(32).bool(message.cache);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechRequestOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechRequestOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.voiceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.audio = SpeechAudioFormat.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.normalize = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cache = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechRequestOption {
    return {
      voiceId: isSet(object.voiceId) ? globalThis.String(object.voiceId) : "",
      audio: isSet(object.audio) ? SpeechAudioFormat.fromJSON(object.audio) : undefined,
      normalize: isSet(object.normalize) ? globalThis.Boolean(object.normalize) : false,
      cache: isSet(object.cache) ? globalThis.Boolean(object.cache) : false,
    };
  },

  toJSON(message: SpeechRequestOption): unknown {
    const obj: any = {};
    if (message.voiceId !== "") {
      obj.voiceId = message.voiceId;
    }
    if (message.audio !== undefined) {
      obj.audio = SpeechAudioFormat.toJSON(message.audio);
    }
    if (message.normalize !== false) {
      obj.normalize = message.normalize;
    }
    if (message.cache !== false) {
      obj.cache = message.cache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpeechRequestOption>, I>>(base?: I): SpeechRequestOption {
    return SpeechRequestOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpeechRequestOption>, I>>(object: I): SpeechRequestOption {
    const message = createBaseSpeechRequestOption();
    message.voiceId = object.voiceId ?? "";
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? SpeechAudioFormat.fromPartial(object.audio)
      : undefined;
    message.normalize = object.normalize ?? false;
    message.cache = object.cache ?? false;
    return message;
  },
};

function createBaseSpeechAudioFormat(): SpeechAudioFormat {
  return { container: 0, codec: 0, samplerate: 0, bitrate: 0, channels: 0 };
}

export const SpeechAudioFormat: MessageFns<SpeechAudioFormat> = {
  encode(message: SpeechAudioFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.container !== 0) {
      writer.uint32(8).int32(message.container);
    }
    if (message.codec !== 0) {
      writer.uint32(16).int32(message.codec);
    }
    if (message.samplerate !== 0) {
      writer.uint32(24).int32(message.samplerate);
    }
    if (message.bitrate !== 0) {
      writer.uint32(32).int32(message.bitrate);
    }
    if (message.channels !== 0) {
      writer.uint32(40).int32(message.channels);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechAudioFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechAudioFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.container = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.codec = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.samplerate = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bitrate = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.channels = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechAudioFormat {
    return {
      container: isSet(object.container) ? speechAudioFormat_ContainerFromJSON(object.container) : 0,
      codec: isSet(object.codec) ? speechAudioFormat_CodecFromJSON(object.codec) : 0,
      samplerate: isSet(object.samplerate) ? globalThis.Number(object.samplerate) : 0,
      bitrate: isSet(object.bitrate) ? globalThis.Number(object.bitrate) : 0,
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
    };
  },

  toJSON(message: SpeechAudioFormat): unknown {
    const obj: any = {};
    if (message.container !== 0) {
      obj.container = speechAudioFormat_ContainerToJSON(message.container);
    }
    if (message.codec !== 0) {
      obj.codec = speechAudioFormat_CodecToJSON(message.codec);
    }
    if (message.samplerate !== 0) {
      obj.samplerate = Math.round(message.samplerate);
    }
    if (message.bitrate !== 0) {
      obj.bitrate = Math.round(message.bitrate);
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpeechAudioFormat>, I>>(base?: I): SpeechAudioFormat {
    return SpeechAudioFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpeechAudioFormat>, I>>(object: I): SpeechAudioFormat {
    const message = createBaseSpeechAudioFormat();
    message.container = object.container ?? 0;
    message.codec = object.codec ?? 0;
    message.samplerate = object.samplerate ?? 0;
    message.bitrate = object.bitrate ?? 0;
    message.channels = object.channels ?? 0;
    return message;
  },
};

function createBaseSpeechLocale(): SpeechLocale {
  return { language: "", accent: "", languageName: "", accentName: "" };
}

export const SpeechLocale: MessageFns<SpeechLocale> = {
  encode(message: SpeechLocale, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.accent !== "") {
      writer.uint32(18).string(message.accent);
    }
    if (message.languageName !== "") {
      writer.uint32(26).string(message.languageName);
    }
    if (message.accentName !== "") {
      writer.uint32(34).string(message.accentName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechLocale {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechLocale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.languageName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechLocale {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      accent: isSet(object.accent) ? globalThis.String(object.accent) : "",
      languageName: isSet(object.languageName) ? globalThis.String(object.languageName) : "",
      accentName: isSet(object.accentName) ? globalThis.String(object.accentName) : "",
    };
  },

  toJSON(message: SpeechLocale): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.accent !== "") {
      obj.accent = message.accent;
    }
    if (message.languageName !== "") {
      obj.languageName = message.languageName;
    }
    if (message.accentName !== "") {
      obj.accentName = message.accentName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpeechLocale>, I>>(base?: I): SpeechLocale {
    return SpeechLocale.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpeechLocale>, I>>(object: I): SpeechLocale {
    const message = createBaseSpeechLocale();
    message.language = object.language ?? "";
    message.accent = object.accent ?? "";
    message.languageName = object.languageName ?? "";
    message.accentName = object.accentName ?? "";
    return message;
  },
};

function createBaseVoiceDefaults(): VoiceDefaults {
  return { rate: "", pitch: "" };
}

export const VoiceDefaults: MessageFns<VoiceDefaults> = {
  encode(message: VoiceDefaults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rate !== "") {
      writer.uint32(10).string(message.rate);
    }
    if (message.pitch !== "") {
      writer.uint32(18).string(message.pitch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoiceDefaults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceDefaults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rate = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pitch = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceDefaults {
    return {
      rate: isSet(object.rate) ? globalThis.String(object.rate) : "",
      pitch: isSet(object.pitch) ? globalThis.String(object.pitch) : "",
    };
  },

  toJSON(message: VoiceDefaults): unknown {
    const obj: any = {};
    if (message.rate !== "") {
      obj.rate = message.rate;
    }
    if (message.pitch !== "") {
      obj.pitch = message.pitch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceDefaults>, I>>(base?: I): VoiceDefaults {
    return VoiceDefaults.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceDefaults>, I>>(object: I): VoiceDefaults {
    const message = createBaseVoiceDefaults();
    message.rate = object.rate ?? "";
    message.pitch = object.pitch ?? "";
    return message;
  },
};

function createBaseVoice(): Voice {
  return {
    name: "",
    audio: undefined,
    locale: undefined,
    gender: 0,
    voiceId: "",
    uuid: "",
    version: "",
    portsAvailable: 0,
    debugAvailable: false,
    defaults: undefined,
  };
}

export const Voice: MessageFns<Voice> = {
  encode(message: Voice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.audio !== undefined) {
      SpeechAudioFormat.encode(message.audio, writer.uint32(18).fork()).join();
    }
    if (message.locale !== undefined) {
      SpeechLocale.encode(message.locale, writer.uint32(26).fork()).join();
    }
    if (message.gender !== 0) {
      writer.uint32(32).int32(message.gender);
    }
    if (message.voiceId !== "") {
      writer.uint32(42).string(message.voiceId);
    }
    if (message.uuid !== "") {
      writer.uint32(50).string(message.uuid);
    }
    if (message.version !== "") {
      writer.uint32(58).string(message.version);
    }
    if (message.portsAvailable !== 0) {
      writer.uint32(64).int32(message.portsAvailable);
    }
    if (message.debugAvailable !== false) {
      writer.uint32(72).bool(message.debugAvailable);
    }
    if (message.defaults !== undefined) {
      VoiceDefaults.encode(message.defaults, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Voice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.audio = SpeechAudioFormat.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locale = SpeechLocale.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.voiceId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.portsAvailable = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.debugAvailable = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.defaults = VoiceDefaults.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Voice {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      audio: isSet(object.audio) ? SpeechAudioFormat.fromJSON(object.audio) : undefined,
      locale: isSet(object.locale) ? SpeechLocale.fromJSON(object.locale) : undefined,
      gender: isSet(object.gender) ? voice_GenderFromJSON(object.gender) : 0,
      voiceId: isSet(object.voiceId) ? globalThis.String(object.voiceId) : "",
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      portsAvailable: isSet(object.portsAvailable) ? globalThis.Number(object.portsAvailable) : 0,
      debugAvailable: isSet(object.debugAvailable) ? globalThis.Boolean(object.debugAvailable) : false,
      defaults: isSet(object.defaults) ? VoiceDefaults.fromJSON(object.defaults) : undefined,
    };
  },

  toJSON(message: Voice): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.audio !== undefined) {
      obj.audio = SpeechAudioFormat.toJSON(message.audio);
    }
    if (message.locale !== undefined) {
      obj.locale = SpeechLocale.toJSON(message.locale);
    }
    if (message.gender !== 0) {
      obj.gender = voice_GenderToJSON(message.gender);
    }
    if (message.voiceId !== "") {
      obj.voiceId = message.voiceId;
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.portsAvailable !== 0) {
      obj.portsAvailable = Math.round(message.portsAvailable);
    }
    if (message.debugAvailable !== false) {
      obj.debugAvailable = message.debugAvailable;
    }
    if (message.defaults !== undefined) {
      obj.defaults = VoiceDefaults.toJSON(message.defaults);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Voice>, I>>(base?: I): Voice {
    return Voice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Voice>, I>>(object: I): Voice {
    const message = createBaseVoice();
    message.name = object.name ?? "";
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? SpeechAudioFormat.fromPartial(object.audio)
      : undefined;
    message.locale = (object.locale !== undefined && object.locale !== null)
      ? SpeechLocale.fromPartial(object.locale)
      : undefined;
    message.gender = object.gender ?? 0;
    message.voiceId = object.voiceId ?? "";
    message.uuid = object.uuid ?? "";
    message.version = object.version ?? "";
    message.portsAvailable = object.portsAvailable ?? 0;
    message.debugAvailable = object.debugAvailable ?? false;
    message.defaults = (object.defaults !== undefined && object.defaults !== null)
      ? VoiceDefaults.fromPartial(object.defaults)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
