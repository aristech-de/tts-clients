// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v3.21.12
// source: TTSServices.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { SpeechLocale, SpeechRequestOption, Voice } from "./TTSTypes.js";

export const protobufPackage = "aristech.tts";

/** Commands that can be used in ServerCommand */
export enum CommandType {
  START_REQUEST = 0,
  STOP_REQUEST = 1,
  STATUS_REQUEST = 2,
  UNRECOGNIZED = -1,
}

export function commandTypeFromJSON(object: any): CommandType {
  switch (object) {
    case 0:
    case "START_REQUEST":
      return CommandType.START_REQUEST;
    case 1:
    case "STOP_REQUEST":
      return CommandType.STOP_REQUEST;
    case 2:
    case "STATUS_REQUEST":
      return CommandType.STATUS_REQUEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandType.UNRECOGNIZED;
  }
}

export function commandTypeToJSON(object: CommandType): string {
  switch (object) {
    case CommandType.START_REQUEST:
      return "START_REQUEST";
    case CommandType.STOP_REQUEST:
      return "STOP_REQUEST";
    case CommandType.STATUS_REQUEST:
      return "STATUS_REQUEST";
    case CommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CommandResponseType {
  /** STARTRESPONSE - Synthesis startet */
  STARTRESPONSE = 0,
  /** STOPRESPONSE - Synthesis stopped */
  STOPRESPONSE = 1,
  /** STATUSRESPONSE - Response contains status information */
  STATUSRESPONSE = 2,
  /** SYNTHESISRESPONSE - Response contains SpeechResponses */
  SYNTHESISRESPONSE = 3,
  UNRECOGNIZED = -1,
}

export function commandResponseTypeFromJSON(object: any): CommandResponseType {
  switch (object) {
    case 0:
    case "STARTRESPONSE":
      return CommandResponseType.STARTRESPONSE;
    case 1:
    case "STOPRESPONSE":
      return CommandResponseType.STOPRESPONSE;
    case 2:
    case "STATUSRESPONSE":
      return CommandResponseType.STATUSRESPONSE;
    case 3:
    case "SYNTHESISRESPONSE":
      return CommandResponseType.SYNTHESISRESPONSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandResponseType.UNRECOGNIZED;
  }
}

export function commandResponseTypeToJSON(object: CommandResponseType): string {
  switch (object) {
    case CommandResponseType.STARTRESPONSE:
      return "STARTRESPONSE";
    case CommandResponseType.STOPRESPONSE:
      return "STOPRESPONSE";
    case CommandResponseType.STATUSRESPONSE:
      return "STATUSRESPONSE";
    case CommandResponseType.SYNTHESISRESPONSE:
      return "SYNTHESISRESPONSE";
    case CommandResponseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * `SpeechRequest` is the top-level message sent by the client for
 * the `getSpeech` method.
 */
export interface SpeechRequest {
  /** Required: The text that will be transformed into audio. */
  text: string;
  /** Required: Further options for the request. */
  options:
    | SpeechRequestOption
    | undefined;
  /** Currently not used */
  parameters: string;
  /** Use "SSML" */
  inputType: string;
  /** Use "AUDIO" */
  outputType: string;
}

export interface PhonesetRequest {
  /**
   * Required: The voice of which the phoneset is requested. Only `Voice.name`
   * has to be filled
   */
  voice: Voice | undefined;
}

export interface PhonesetResponse {
  status: number;
  message: string;
  /** A json array that contains a representation of the phoneset */
  phoneset: string;
}

export interface TranscriptionRequest {
  /**
   * Required: The voice of which the phoneset is requested. Only `Voice.name`
   * has to be filled
   */
  voice:
    | Voice
    | undefined;
  /** Required: The word to be transcribed */
  word: string;
}

export interface TranscriptionResponse {
  status: number;
  message: string;
  /** The transcription of the submitted word */
  transcription: string;
}

/**
 * A command that is sent to the speech engine. START_REQUEST has to encapsulate
 * a SpeechRequest.
 */
export interface ServerCommand {
  commandType: CommandType;
  commandData: Uint8Array;
  speechRequest: SpeechRequest | undefined;
}

/** The server's response to a ServerCommand. */
export interface ServerCommandResponse {
  responseType: CommandResponseType;
  status: number;
  message: string;
  responseData: Uint8Array;
  speechResponse: SpeechResponse[];
}

/**
 * `SpeechResponse` is the top-level message sent by the server for
 * the `getSpeech` and `ProcessData`methods. Possibly multiple `SpeechResponse`
 * messages are sent while the audio is being generated.
 * When the requested output_type is a text type, there will be only one
 * SpeechResponse that contains the whole block.
 * Howevery, output_type AUDIO will return multiple blocks of audio signal
 * that have to be concatenated or streamed to an audio device
 */
export interface SpeechResponse {
  /**
   * The audio data bytes encoded as specified in
   * `SpeechRequestOptionAudioFormat`.
   */
  status: number;
  data: Uint8Array;
  inputType: string;
  outputType: string;
}

/**
 * Requests a VoiceListResponse that contains all available voices (with the
 * specified locale)
 */
export interface VoiceListRequest {
  locale: SpeechLocale | undefined;
}

function createBaseSpeechRequest(): SpeechRequest {
  return { text: "", options: undefined, parameters: "", inputType: "", outputType: "" };
}

export const SpeechRequest: MessageFns<SpeechRequest> = {
  encode(message: SpeechRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.options !== undefined) {
      SpeechRequestOption.encode(message.options, writer.uint32(18).fork()).join();
    }
    if (message.parameters !== "") {
      writer.uint32(26).string(message.parameters);
    }
    if (message.inputType !== "") {
      writer.uint32(34).string(message.inputType);
    }
    if (message.outputType !== "") {
      writer.uint32(42).string(message.outputType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.options = SpeechRequestOption.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameters = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.outputType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechRequest {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      options: isSet(object.options) ? SpeechRequestOption.fromJSON(object.options) : undefined,
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      inputType: isSet(object.inputType) ? globalThis.String(object.inputType) : "",
      outputType: isSet(object.outputType) ? globalThis.String(object.outputType) : "",
    };
  },

  toJSON(message: SpeechRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.options !== undefined) {
      obj.options = SpeechRequestOption.toJSON(message.options);
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.inputType !== "") {
      obj.inputType = message.inputType;
    }
    if (message.outputType !== "") {
      obj.outputType = message.outputType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpeechRequest>, I>>(base?: I): SpeechRequest {
    return SpeechRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpeechRequest>, I>>(object: I): SpeechRequest {
    const message = createBaseSpeechRequest();
    message.text = object.text ?? "";
    message.options = (object.options !== undefined && object.options !== null)
      ? SpeechRequestOption.fromPartial(object.options)
      : undefined;
    message.parameters = object.parameters ?? "";
    message.inputType = object.inputType ?? "";
    message.outputType = object.outputType ?? "";
    return message;
  },
};

function createBasePhonesetRequest(): PhonesetRequest {
  return { voice: undefined };
}

export const PhonesetRequest: MessageFns<PhonesetRequest> = {
  encode(message: PhonesetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.voice !== undefined) {
      Voice.encode(message.voice, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhonesetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhonesetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.voice = Voice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhonesetRequest {
    return { voice: isSet(object.voice) ? Voice.fromJSON(object.voice) : undefined };
  },

  toJSON(message: PhonesetRequest): unknown {
    const obj: any = {};
    if (message.voice !== undefined) {
      obj.voice = Voice.toJSON(message.voice);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhonesetRequest>, I>>(base?: I): PhonesetRequest {
    return PhonesetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhonesetRequest>, I>>(object: I): PhonesetRequest {
    const message = createBasePhonesetRequest();
    message.voice = (object.voice !== undefined && object.voice !== null) ? Voice.fromPartial(object.voice) : undefined;
    return message;
  },
};

function createBasePhonesetResponse(): PhonesetResponse {
  return { status: 0, message: "", phoneset: "" };
}

export const PhonesetResponse: MessageFns<PhonesetResponse> = {
  encode(message: PhonesetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int64(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.phoneset !== "") {
      writer.uint32(26).string(message.phoneset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhonesetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhonesetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phoneset = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhonesetResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      phoneset: isSet(object.phoneset) ? globalThis.String(object.phoneset) : "",
    };
  },

  toJSON(message: PhonesetResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.phoneset !== "") {
      obj.phoneset = message.phoneset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhonesetResponse>, I>>(base?: I): PhonesetResponse {
    return PhonesetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhonesetResponse>, I>>(object: I): PhonesetResponse {
    const message = createBasePhonesetResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.phoneset = object.phoneset ?? "";
    return message;
  },
};

function createBaseTranscriptionRequest(): TranscriptionRequest {
  return { voice: undefined, word: "" };
}

export const TranscriptionRequest: MessageFns<TranscriptionRequest> = {
  encode(message: TranscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.voice !== undefined) {
      Voice.encode(message.voice, writer.uint32(10).fork()).join();
    }
    if (message.word !== "") {
      writer.uint32(18).string(message.word);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.voice = Voice.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.word = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptionRequest {
    return {
      voice: isSet(object.voice) ? Voice.fromJSON(object.voice) : undefined,
      word: isSet(object.word) ? globalThis.String(object.word) : "",
    };
  },

  toJSON(message: TranscriptionRequest): unknown {
    const obj: any = {};
    if (message.voice !== undefined) {
      obj.voice = Voice.toJSON(message.voice);
    }
    if (message.word !== "") {
      obj.word = message.word;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TranscriptionRequest>, I>>(base?: I): TranscriptionRequest {
    return TranscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TranscriptionRequest>, I>>(object: I): TranscriptionRequest {
    const message = createBaseTranscriptionRequest();
    message.voice = (object.voice !== undefined && object.voice !== null) ? Voice.fromPartial(object.voice) : undefined;
    message.word = object.word ?? "";
    return message;
  },
};

function createBaseTranscriptionResponse(): TranscriptionResponse {
  return { status: 0, message: "", transcription: "" };
}

export const TranscriptionResponse: MessageFns<TranscriptionResponse> = {
  encode(message: TranscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int64(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.transcription !== "") {
      writer.uint32(26).string(message.transcription);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transcription = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptionResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      transcription: isSet(object.transcription) ? globalThis.String(object.transcription) : "",
    };
  },

  toJSON(message: TranscriptionResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.transcription !== "") {
      obj.transcription = message.transcription;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TranscriptionResponse>, I>>(base?: I): TranscriptionResponse {
    return TranscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TranscriptionResponse>, I>>(object: I): TranscriptionResponse {
    const message = createBaseTranscriptionResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.transcription = object.transcription ?? "";
    return message;
  },
};

function createBaseServerCommand(): ServerCommand {
  return { commandType: 0, commandData: new Uint8Array(0), speechRequest: undefined };
}

export const ServerCommand: MessageFns<ServerCommand> = {
  encode(message: ServerCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandType !== 0) {
      writer.uint32(8).int32(message.commandType);
    }
    if (message.commandData.length !== 0) {
      writer.uint32(18).bytes(message.commandData);
    }
    if (message.speechRequest !== undefined) {
      SpeechRequest.encode(message.speechRequest, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.commandType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandData = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.speechRequest = SpeechRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerCommand {
    return {
      commandType: isSet(object.commandType) ? commandTypeFromJSON(object.commandType) : 0,
      commandData: isSet(object.commandData) ? bytesFromBase64(object.commandData) : new Uint8Array(0),
      speechRequest: isSet(object.speechRequest) ? SpeechRequest.fromJSON(object.speechRequest) : undefined,
    };
  },

  toJSON(message: ServerCommand): unknown {
    const obj: any = {};
    if (message.commandType !== 0) {
      obj.commandType = commandTypeToJSON(message.commandType);
    }
    if (message.commandData.length !== 0) {
      obj.commandData = base64FromBytes(message.commandData);
    }
    if (message.speechRequest !== undefined) {
      obj.speechRequest = SpeechRequest.toJSON(message.speechRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerCommand>, I>>(base?: I): ServerCommand {
    return ServerCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerCommand>, I>>(object: I): ServerCommand {
    const message = createBaseServerCommand();
    message.commandType = object.commandType ?? 0;
    message.commandData = object.commandData ?? new Uint8Array(0);
    message.speechRequest = (object.speechRequest !== undefined && object.speechRequest !== null)
      ? SpeechRequest.fromPartial(object.speechRequest)
      : undefined;
    return message;
  },
};

function createBaseServerCommandResponse(): ServerCommandResponse {
  return { responseType: 0, status: 0, message: "", responseData: new Uint8Array(0), speechResponse: [] };
}

export const ServerCommandResponse: MessageFns<ServerCommandResponse> = {
  encode(message: ServerCommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseType !== 0) {
      writer.uint32(8).int32(message.responseType);
    }
    if (message.status !== 0) {
      writer.uint32(16).int64(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.responseData.length !== 0) {
      writer.uint32(34).bytes(message.responseData);
    }
    for (const v of message.speechResponse) {
      SpeechResponse.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerCommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.responseType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.responseData = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.speechResponse.push(SpeechResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerCommandResponse {
    return {
      responseType: isSet(object.responseType) ? commandResponseTypeFromJSON(object.responseType) : 0,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      responseData: isSet(object.responseData) ? bytesFromBase64(object.responseData) : new Uint8Array(0),
      speechResponse: globalThis.Array.isArray(object?.speechResponse)
        ? object.speechResponse.map((e: any) => SpeechResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServerCommandResponse): unknown {
    const obj: any = {};
    if (message.responseType !== 0) {
      obj.responseType = commandResponseTypeToJSON(message.responseType);
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.responseData.length !== 0) {
      obj.responseData = base64FromBytes(message.responseData);
    }
    if (message.speechResponse?.length) {
      obj.speechResponse = message.speechResponse.map((e) => SpeechResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerCommandResponse>, I>>(base?: I): ServerCommandResponse {
    return ServerCommandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerCommandResponse>, I>>(object: I): ServerCommandResponse {
    const message = createBaseServerCommandResponse();
    message.responseType = object.responseType ?? 0;
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.responseData = object.responseData ?? new Uint8Array(0);
    message.speechResponse = object.speechResponse?.map((e) => SpeechResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpeechResponse(): SpeechResponse {
  return { status: 0, data: new Uint8Array(0), inputType: "", outputType: "" };
}

export const SpeechResponse: MessageFns<SpeechResponse> = {
  encode(message: SpeechResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int64(message.status);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.inputType !== "") {
      writer.uint32(26).string(message.inputType);
    }
    if (message.outputType !== "") {
      writer.uint32(34).string(message.outputType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      inputType: isSet(object.inputType) ? globalThis.String(object.inputType) : "",
      outputType: isSet(object.outputType) ? globalThis.String(object.outputType) : "",
    };
  },

  toJSON(message: SpeechResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.inputType !== "") {
      obj.inputType = message.inputType;
    }
    if (message.outputType !== "") {
      obj.outputType = message.outputType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpeechResponse>, I>>(base?: I): SpeechResponse {
    return SpeechResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpeechResponse>, I>>(object: I): SpeechResponse {
    const message = createBaseSpeechResponse();
    message.status = object.status ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.inputType = object.inputType ?? "";
    message.outputType = object.outputType ?? "";
    return message;
  },
};

function createBaseVoiceListRequest(): VoiceListRequest {
  return { locale: undefined };
}

export const VoiceListRequest: MessageFns<VoiceListRequest> = {
  encode(message: VoiceListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locale !== undefined) {
      SpeechLocale.encode(message.locale, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoiceListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locale = SpeechLocale.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceListRequest {
    return { locale: isSet(object.locale) ? SpeechLocale.fromJSON(object.locale) : undefined };
  },

  toJSON(message: VoiceListRequest): unknown {
    const obj: any = {};
    if (message.locale !== undefined) {
      obj.locale = SpeechLocale.toJSON(message.locale);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceListRequest>, I>>(base?: I): VoiceListRequest {
    return VoiceListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceListRequest>, I>>(object: I): VoiceListRequest {
    const message = createBaseVoiceListRequest();
    message.locale = (object.locale !== undefined && object.locale !== null)
      ? SpeechLocale.fromPartial(object.locale)
      : undefined;
    return message;
  },
};

/** Service that implements Aristech Speech-API (TTS-API, ariTTS) */
export type SpeechServiceService = typeof SpeechServiceService;
export const SpeechServiceService = {
  /**
   * Performs Text-to-Speech with the given SpeechRequest and streams back the
   * audio as packets of type SpeechResponse.
   */
  getSpeech: {
    path: "/aristech.tts.SpeechService/GetSpeech",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SpeechRequest) => Buffer.from(SpeechRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SpeechRequest.decode(value),
    responseSerialize: (value: SpeechResponse) => Buffer.from(SpeechResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SpeechResponse.decode(value),
  },
  /**
   * Performs Text-to-Speech and streams back the audio. Adds the capability to
   * stop the speech synthesis and free a port during synthesis.
   */
  controlServer: {
    path: "/aristech.tts.SpeechService/ControlServer",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ServerCommand) => Buffer.from(ServerCommand.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ServerCommand.decode(value),
    responseSerialize: (value: ServerCommandResponse) => Buffer.from(ServerCommandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ServerCommandResponse.decode(value),
  },
  /** Returns available voices as stream. */
  getVoiceList: {
    path: "/aristech.tts.SpeechService/GetVoiceList",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: VoiceListRequest) => Buffer.from(VoiceListRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VoiceListRequest.decode(value),
    responseSerialize: (value: Voice) => Buffer.from(Voice.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Voice.decode(value),
  },
  /** Returns the phoneset for a given voice */
  getPhoneset: {
    path: "/aristech.tts.SpeechService/GetPhoneset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PhonesetRequest) => Buffer.from(PhonesetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PhonesetRequest.decode(value),
    responseSerialize: (value: PhonesetResponse) => Buffer.from(PhonesetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PhonesetResponse.decode(value),
  },
  /** Returns the transcription for a word for a given voice */
  getTranscription: {
    path: "/aristech.tts.SpeechService/GetTranscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TranscriptionRequest) => Buffer.from(TranscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TranscriptionRequest.decode(value),
    responseSerialize: (value: TranscriptionResponse) => Buffer.from(TranscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TranscriptionResponse.decode(value),
  },
} as const;

export interface SpeechServiceServer extends UntypedServiceImplementation {
  /**
   * Performs Text-to-Speech with the given SpeechRequest and streams back the
   * audio as packets of type SpeechResponse.
   */
  getSpeech: handleServerStreamingCall<SpeechRequest, SpeechResponse>;
  /**
   * Performs Text-to-Speech and streams back the audio. Adds the capability to
   * stop the speech synthesis and free a port during synthesis.
   */
  controlServer: handleBidiStreamingCall<ServerCommand, ServerCommandResponse>;
  /** Returns available voices as stream. */
  getVoiceList: handleServerStreamingCall<VoiceListRequest, Voice>;
  /** Returns the phoneset for a given voice */
  getPhoneset: handleUnaryCall<PhonesetRequest, PhonesetResponse>;
  /** Returns the transcription for a word for a given voice */
  getTranscription: handleUnaryCall<TranscriptionRequest, TranscriptionResponse>;
}

export interface SpeechServiceClient extends Client {
  /**
   * Performs Text-to-Speech with the given SpeechRequest and streams back the
   * audio as packets of type SpeechResponse.
   */
  getSpeech(request: SpeechRequest, options?: Partial<CallOptions>): ClientReadableStream<SpeechResponse>;
  getSpeech(
    request: SpeechRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SpeechResponse>;
  /**
   * Performs Text-to-Speech and streams back the audio. Adds the capability to
   * stop the speech synthesis and free a port during synthesis.
   */
  controlServer(): ClientDuplexStream<ServerCommand, ServerCommandResponse>;
  controlServer(options: Partial<CallOptions>): ClientDuplexStream<ServerCommand, ServerCommandResponse>;
  controlServer(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ServerCommand, ServerCommandResponse>;
  /** Returns available voices as stream. */
  getVoiceList(request: VoiceListRequest, options?: Partial<CallOptions>): ClientReadableStream<Voice>;
  getVoiceList(
    request: VoiceListRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Voice>;
  /** Returns the phoneset for a given voice */
  getPhoneset(
    request: PhonesetRequest,
    callback: (error: ServiceError | null, response: PhonesetResponse) => void,
  ): ClientUnaryCall;
  getPhoneset(
    request: PhonesetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PhonesetResponse) => void,
  ): ClientUnaryCall;
  getPhoneset(
    request: PhonesetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PhonesetResponse) => void,
  ): ClientUnaryCall;
  /** Returns the transcription for a word for a given voice */
  getTranscription(
    request: TranscriptionRequest,
    callback: (error: ServiceError | null, response: TranscriptionResponse) => void,
  ): ClientUnaryCall;
  getTranscription(
    request: TranscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TranscriptionResponse) => void,
  ): ClientUnaryCall;
  getTranscription(
    request: TranscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TranscriptionResponse) => void,
  ): ClientUnaryCall;
}

export const SpeechServiceClient = makeGenericClientConstructor(
  SpeechServiceService,
  "aristech.tts.SpeechService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SpeechServiceClient;
  service: typeof SpeechServiceService;
  serviceName: string;
};

/** Internal Use Only: debug access to engine */
export type DebugServiceService = typeof DebugServiceService;
export const DebugServiceService = {
  processData: {
    path: "/aristech.tts.DebugService/ProcessData",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SpeechRequest) => Buffer.from(SpeechRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SpeechRequest.decode(value),
    responseSerialize: (value: SpeechResponse) => Buffer.from(SpeechResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SpeechResponse.decode(value),
  },
} as const;

export interface DebugServiceServer extends UntypedServiceImplementation {
  processData: handleServerStreamingCall<SpeechRequest, SpeechResponse>;
}

export interface DebugServiceClient extends Client {
  processData(request: SpeechRequest, options?: Partial<CallOptions>): ClientReadableStream<SpeechResponse>;
  processData(
    request: SpeechRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SpeechResponse>;
}

export const DebugServiceClient = makeGenericClientConstructor(
  DebugServiceService,
  "aristech.tts.DebugService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DebugServiceClient;
  service: typeof DebugServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
